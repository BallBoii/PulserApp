# pulseblaster.py
# Generated by PulseBlaster Visual Editor
from dataclasses import dataclass
import json
import sys
from typing import Iterable, Optional, Sequence, Union
import time

import spinapi as sp  # uses your local spinapi.py

# ---------------------------
# Dataclass: one "instruction" row
# ---------------------------
@dataclass
class PBInstruction:
    """
    One PulseBlaster instruction row.

    flags:
        - int: bitmask of digital output lines (LSB = flag0)
        - str: string like '101100...' where the **first character is flag0** (becomes the LSB)
        - Sequence[int]: list of flag indices to set HIGH, e.g. [0, 3, 5]

    opcode:
        String name: 'CONTINUE','STOP','LOOP','END_LOOP','JSR','RTS',
        'BRANCH','LONG_DELAY','WAIT','RTI'.

    data:
        The inst_data field for the opcode (e.g., jump address, loop count).

    duration:
        Time to hold outputs for this instruction.

    units:
        One of 'ns' (default), 'us', 'ms', 's'.

    DDS fields (if any freq*/phase*/amp* is not None, the wrapper calls pb_inst_dds2):
        freq0, phase0, amp0, dds_en0, phase_reset0,
        freq1, phase1, amp1, dds_en1, phase_reset1

        **Important:** freq*/phase*/amp* are **register IDs**, not raw values.
        You must load them first with program_freq_regs / program_phase_regs / program_amp_regs.
        Missing fields are passed as -1 to pb_inst_dds2 (commonly interpreted as "do not change"),
        but consult your board manual—explicitly providing IDs is the safest.
    """
    flags: Union[int, str, Sequence[int]] = 0
    opcode: str = "CONTINUE"
    data: int = 0
    duration: float = 100.0
    units: str = "ns"

    # DDS fields (register IDs; not raw Hz/deg/amp)
    freq0: Optional[int] = None
    phase0: Optional[int] = None
    amp0: Optional[int] = None
    dds_en0: int = 1
    phase_reset0: int = sp.NO_PHASE_RESET

    freq1: Optional[int] = None
    phase1: Optional[int] = None
    amp1: Optional[int] = None
    dds_en1: int = 1
    phase_reset1: int = sp.NO_PHASE_RESET


# ---------------------------
# Internal helpers
# ---------------------------
_OPCODES = {
    "CONTINUE": sp.CONTINUE,
    "STOP":     sp.STOP,
    "LOOP":     sp.LOOP,
    "END_LOOP": sp.END_LOOP,
    "JSR":      sp.JSR,
    "RTS":      sp.RTS,
    "BRANCH":   sp.BRANCH,
    "LONG_DELAY": sp.LONG_DELAY,
    "WAIT":     sp.WAIT,
    "RTI":      sp.RTI,
}

_UNIT_SCALE = {
    "ns": sp.ns,
    "us": sp.us,
    "ms": sp.ms,
    "s":  sp.s,
}

def _encode_flags(flags: Union[int, str, Sequence[int]]) -> int:
    """Normalize various flag encodings into an integer bitmask (LSB = flag0)."""
    if isinstance(flags, int):
        return flags
    if isinstance(flags, str):
        # First character is flag0 -> becomes the LSB
        val = 0
        for i, ch in enumerate(flags):
            if ch not in ("0", "1"):
                raise ValueError("flags string must contain only '0' or '1'")
            if ch == "1":
                val |= (1 << i)
        return val
    # Sequence of indices
    mask = 0
    for idx in flags:
        if idx < 0:
            raise ValueError("flag index must be non-negative")
        mask |= (1 << idx)
    return mask

def _validate_instruction(ins: PBInstruction) -> None:
    """Validate a PBInstruction for common errors."""
    if ins.duration <= 0:
        raise ValueError(f"duration must be positive, got {ins.duration}")
    
    if ins.opcode.upper() not in _OPCODES:
        raise ValueError(f"invalid opcode '{ins.opcode}', must be one of {list(_OPCODES.keys())}")
    
    # Validate DDS register IDs if specified
    for field_name, value in [("freq0", ins.freq0), ("freq1", ins.freq1),
                              ("phase0", ins.phase0), ("phase1", ins.phase1),
                              ("amp0", ins.amp0), ("amp1", ins.amp1)]:
        if value is not None and (value < -1 or value > 1023):  # Typical register range
            raise ValueError(f"{field_name} register ID must be -1 to 1023, got {value}")

def _dur_to_pb_units(duration: float, units: str) -> float:
    units = units.lower()
    if units not in _UNIT_SCALE:
        raise ValueError(f"units must be one of {list(_UNIT_SCALE)}")
    return duration * _UNIT_SCALE[units]


# ---------------------------
# Main class: PulseBlaster
# ---------------------------
class PulseBlaster:
    """
    Object-oriented wrapper for SpinCore PulseBlaster.

    Features:
      - Context manager support (with PulseBlaster(...) as pb)
      - Set core clock; write default digital flags
      - Load DDS registers (frequency / phase / amplitude)
      - Program both PB-only and DDS instructions
      - Start/stop/reset and friendly status helpers
    """

    def __init__(self, board: int = 0, core_clock_MHz: Optional[float] = None, debug: bool = False):
        self.board = board
        self.core_clock_MHz = core_clock_MHz
        self.debug = debug
        self._opened = False

    # --- Context manager ---
    def __enter__(self):
        self.open()
        return self

    def __exit__(self, exc_type, exc, tb):
        # Always close, even if an exception occurs
        try:
            self.close()
        finally:
            return False  # propagate exceptions, if any

    # --- Lifecycle ---
    def open(self):
        if self._opened:
            return
        sp.pb_set_debug(int(bool(self.debug)))
        sp.pb_select_board(self.board)
        sp.pb_init()  # raises RuntimeError on failure
        if self.core_clock_MHz is not None:
            sp.pb_core_clock(float(self.core_clock_MHz))
        self._opened = True

    def close(self):
        if not self._opened:
            return
        try:
            sp.pb_stop()
        except Exception:
            pass
        try:
            sp.pb_close()
        finally:
            self._opened = False

    # --- Basic control ---
    def reset(self):
        sp.pb_reset()

    def start(self):
        sp.pb_start()

    def stop(self):
        sp.pb_stop()

    # --- Status helpers ---
    def status_bits(self) -> dict:
        """Return dict: {'stopped': bool, 'reset': bool, 'running': bool, 'waiting': bool}."""
        return sp.pb_read_status()

    def status_text(self) -> str:
        """Return human-readable status string from firmware (if supported by the board)."""
        msg = sp.pb_status_message()
        return msg.decode() if isinstance(msg, (bytes, bytearray)) else str(msg)

    def wait_until_stopped(self, timeout_s: float = 5.0, poll_s: float = 0.01) -> bool:
        """
        Poll status until 'stopped' or timeout.
        Returns True if stopped before timeout, else False.
        """
        deadline = time.time() + timeout_s
        while time.time() < deadline:
            if self.status_bits().get("stopped", False):
                return True
            time.sleep(poll_s)
        return False

    # --- Defaults & registers ---
    def write_default_flags(self, flags: Union[int, str, Sequence[int]]):
        sp.pb_write_default_flag(_encode_flags(flags))

    def program_freq_regs(self, *freq_values: float) -> Union[int, tuple]:
        """
        Load frequency registers.

        IMPORTANT: SpinAPI expects values in **MHz units** using the provided multipliers:
            100*sp.MHz, 500*sp.kHz, 1*sp.Hz, ...
        Examples:
            10*sp.MHz   -> 10.0 MHz
            500*sp.kHz  -> 0.5  MHz
            1*sp.Hz     -> 1e-6 MHz
        Returns register ID(s): an int if one value was given, otherwise a tuple of IDs.
        """
        return sp.program_freq_regs(*freq_values)

    def program_phase_regs(self, *phase_deg: float) -> Union[int, tuple]:
        """Load phase registers in degrees. Returns register ID(s)."""
        return sp.program_phase_regs(*phase_deg)

    def program_amp_regs(self, *amps: float) -> Union[int, tuple]:
        """Load amplitude registers (usually 0.0–1.0). Returns register ID(s)."""
        return sp.program_amp_regs(*amps)

    # --- Programming ---
    def validate_program(self, instructions: Iterable[PBInstruction]) -> list[str]:
        """
        Validate a program for common issues. Returns list of warning messages.
        """
        warnings = []
        instructions = list(instructions)  # Convert to list for multiple iterations
        
        if not instructions:
            warnings.append("Empty instruction list")
            return warnings
            
        # Check for balanced LOOP/END_LOOP
        loop_depth = 0
        for i, ins in enumerate(instructions):
            if ins.opcode.upper() == "LOOP":
                loop_depth += 1
            elif ins.opcode.upper() == "END_LOOP":
                loop_depth -= 1
                if loop_depth < 0:
                    warnings.append(f"Instruction {i}: END_LOOP without matching LOOP")
        
        if loop_depth > 0:
            warnings.append("Unmatched LOOP instructions (missing END_LOOP)")
            
        # Check if program ends properly
        last_ins = instructions[-1]
        if last_ins.opcode.upper() not in ["STOP", "BRANCH"]:
            warnings.append("Program should typically end with STOP or BRANCH instruction")
            
        return warnings

    def program_pulse_program(self, instructions: Iterable[PBInstruction],
                              default_flags: Optional[Union[int, str, Sequence[int]]] = None,
                              validate: bool = True):
        """
        Program the PULSE_PROGRAM with a list of PBInstruction.
        If any instruction specifies DDS fields (freq*/phase*/amp* not None),
        the wrapper uses pb_inst_dds2 for that line; otherwise it uses pb_inst_pbonly.
        
        validate: If True, check for common programming errors and print warnings.
        """
        instructions = list(instructions)  # Convert to list for validation
        
        if validate:
            warnings = self.validate_program(instructions)
            if warnings:
                print("Program validation warnings:")
                for warning in warnings:
                    print(f"  - {warning}")
        
        if default_flags is not None:
            self.write_default_flags(default_flags)

        sp.pb_start_programming(sp.PULSE_PROGRAM)

        for ins in instructions:
            _validate_instruction(ins)
            flags = _encode_flags(ins.flags)
            inst_code = _OPCODES[ins.opcode.upper()]
            dur = _dur_to_pb_units(ins.duration, ins.units)

            # Choose between PB-only or DDS2
            if ins.freq0 is None and ins.freq1 is None:
                # PB only
                sp.pb_inst_pbonly(flags, inst_code, int(ins.data), float(dur))
            else:
                # DDS2: pass register IDs; -1 commonly means "keep previous" (board-dependent)
                f0 = -1 if ins.freq0 is None else int(ins.freq0)
                p0 = -1 if ins.phase0 is None else int(ins.phase0)
                a0 = -1 if ins.amp0 is None else int(ins.amp0)

                f1 = -1 if ins.freq1 is None else int(ins.freq1)
                p1 = -1 if ins.phase1 is None else int(ins.phase1)
                a1 = -1 if ins.amp1 is None else int(ins.amp1)

                sp.pb_inst_dds2(
                    f0, p0, a0, int(ins.dds_en0), int(ins.phase_reset0),
                    f1, p1, a1, int(ins.dds_en1), int(ins.phase_reset1),
                    flags, inst_code, int(ins.data), float(dur)
                )

        sp.pb_stop_programming()

    def program_pulse_sequence(
        self,
        pulse_patterns: Sequence[tuple[Union[int, str, Sequence[int]], float, str]],
        repeat_count: int = 1
    ):
        """
        Program a sequence of pulses with optional repetition.
        
        pulse_patterns: List of (flags, duration, units) tuples
        repeat_count: Number of times to repeat the sequence (1 = no repeat)
        
        Example:
            pb.program_pulse_sequence([
                ([0, 1], 100, 'us'),    # Flags 0,1 ON for 100us
                ([2], 200, 'us'),       # Flag 2 ON for 200us  
                (0, 50, 'us')           # All OFF for 50us
            ], repeat_count=10)
        """
        instrs = []
        
        if repeat_count > 1:
            instrs.append(PBInstruction(opcode="LOOP", data=repeat_count, duration=100, units="ns"))
        
        # Add pulse sequence
        for flags, duration, units in pulse_patterns:
            instrs.append(PBInstruction(flags=flags, opcode="CONTINUE", duration=duration, units=units))
        
        if repeat_count > 1:
            instrs.append(PBInstruction(opcode="END_LOOP", data=0, duration=100, units="ns"))
        
        # Final STOP instruction
        instrs.append(PBInstruction(opcode="STOP", duration=100, units="ns"))
        
        self.program_pulse_program(instrs)


def main():
    cmd = sys.argv[1] if len(sys.argv) > 1 else "run"
    
    try:
        match cmd:
            case "run":
                payload = json.load(sys.stdin)   # { "board":0, "coreClockMHz":100.0, "defaultFlags":"1...", "program":[...] }
                pb = PulseBlaster(board=payload.get("board", 0),
                                  core_clock_MHz=payload.get("coreClockMHz"),
                                  debug=payload.get("debug", False))
            
                if "defaultFlags" in payload:
                    pb.write_default_flags(payload["defaultFlags"])

                instrs = [PBInstruction(**ins) for ins in payload["program"]]
                
                # Validate program before running
                warnings = pb.validate_program(instrs)
                pb.program_pulse_program(instrs)
                pb.start()
                
                result = {"ok": True, "message": "Program started successfully"}
                if warnings:
                    result["warnings"] = warnings
                print(json.dumps(result))
                
                # Don't close the PulseBlaster here - let it keep running
                # The stop command will handle closing it when needed

            case "start":
                with PulseBlaster() as pb:
                    pb.start()
                print(json.dumps({"ok": True, "message": "PulseBlaster started"}))

            case "stop":
                with PulseBlaster() as pb:
                    pb.stop()
                print(json.dumps({"ok": True, "message": "PulseBlaster stopped"}))

            case "reset":
                with PulseBlaster() as pb:
                    pb.reset()
                print(json.dumps({"ok": True, "message": "PulseBlaster reset"}))

            case "status":
                with PulseBlaster() as pb:
                    status_bits = pb.status_bits()
                    status_text = pb.status_text()
                    print(json.dumps({
                        "ok": True,
                        "status_bits": status_bits,
                        "status_text": status_text
                    }))
                    
            case "wait":
                payload = json.load(sys.stdin)  # { "timeout_s": 10.0 }
                with PulseBlaster() as pb:
                    success = pb.wait_until_stopped(timeout_s=payload.get("timeout_s", 10.0))
                    print(json.dumps({
                        "ok": True, 
                        "stopped": success,
                        "message": "Wait completed"
                    }))

            case "help":
                print(json.dumps({
                    "ok": True,
                    "commands": ["run", "stop", "reset", "status", "wait"]
                }))
                    
            case _:
                print(json.dumps({"ok": False, "error": f"Unknown command: {cmd}"}), file=sys.stderr)
                sys.exit(1)
                
    except Exception as e:
        print(json.dumps({"ok": False, "error": str(e)}), file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()